#!/usr/bin/env uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "click",
#     "requests",
#     "semver",
#     "python-dotenv",
# ]
# ///

import os
import json
from pathlib import Path
from typing import Final
import click
import requests
import sys
import time
from datetime import datetime
from collections import defaultdict
# Add dotenv support
from dotenv import load_dotenv

load_dotenv()  # Load from .env if available]

HOUDINI_FALLBACK_VERSION: Final[str] = os.getenv("HOUDINI_FALLBACK_VERSION", "20.5.584")
HOUDINI_DEFAULT_MIN_VERSION: Final[str] = "20.5"
HOUDINI_VERSIONS_CACHE_NAME: Final[str] = "houdini_versions_cache.json"
HOUDINI_DEFAULT_CACHE_DIR: Final[Path] = Path(os.getenv("CACHE_DIRECTORY", Path.home() / '.aibridge-cache'))
HOUDINI_VERSIONS_CACHE: Final[Path] = HOUDINI_DEFAULT_CACHE_DIR / HOUDINI_VERSIONS_CACHE_NAME
HOUDINI_INSTALLERS_DIR: Final[Path] = HOUDINI_DEFAULT_CACHE_DIR / "installers"
def parse_houdini_version(version_str: str, build_str: str|None=None):
    """Parse Houdini version string with optional build number for comparison."""
    try:
        parts = version_str.split('.')

        # Handle Houdini's two-part version format (e.g., "20.5")
        if len(parts) == 2:
            major, minor = map(float, parts)  # Use float to handle "20.5"
            patch = int(build_str) if build_str else 0
            # Convert to tuple for comparison
            return (int(major), int(minor * 10), patch)
        else:
            while len(parts) < 3:
                parts.append('0')
            major, minor, patch = map(int, parts[:3])
            return (major, minor, patch)
    except Exception as e:
        print(f"Failed to parse version: {version_str}.{build_str} - {e}", file=sys.stderr)
        return (0, 0, 0)

def compare_versions(version1, version2):
    """Compare two Houdini version strings (with build numbers)."""
    v1_parts = version1.split('.')
    v2_parts = version2.split('.')

    # Extract main version and build
    if len(v1_parts) == 3:
        v1_main, v1_build = '.'.join(v1_parts[:2]), v1_parts[2]
    else:
        v1_main, v1_build = version1, "0"

    if len(v2_parts) == 3:
        v2_main, v2_build = '.'.join(v2_parts[:2]), v2_parts[2]
    else:
        v2_main, v2_build = version2, "0"

    # Compare main versions first
    v1_tuple = parse_houdini_version(v1_main)
    v2_tuple = parse_houdini_version(v2_main)

    if v1_tuple != v2_tuple:
        return -1 if v1_tuple < v2_tuple else 1

    # If main versions are equal, compare build numbers
    return -1 if int(v1_build) < int(v2_build) else (0 if int(v1_build) == int(v2_build) else 1)

def is_version_gte(version, min_version):
    """Check if version is greater than or equal to min_version."""
    return compare_versions(version, min_version) >= 0

def get_version_range_for_testing(min_version: str="20.5", cache_file: Path=HOUDINI_VERSIONS_CACHE):
    """Get oldest and newest builds for each major.minor release using authenticated API."""
    # Check for environment variable override first
    env_versions = os.environ.get("HOUDINI_TEST_VERSIONS")
    if env_versions:
        versions = env_versions.split(",")
        # Filter versions based on minimum
        return [v for v in versions if is_version_gte(v, min_version)]

    # Check if we should use cache first (for GitHub Actions)
    if os.environ.get("CACHE_HIT", "true") == "true" and cache_file.exists():
        # Check cache age
        cache_age_hours = 0
        try:
            mtime = os.path.getmtime(cache_file)
            cache_age_hours = (time.time() - mtime) / 3600
        except Exception as e:
            print(f"Failed to get cache file modification time: {e}", file=sys.stderr)
            pass

        # Use cache if it's less than 24 hours old
        if cache_age_hours < 24:
            try:
                with open(cache_file, 'r') as f:
                    cached_data = json.load(f)
                    cached_versions = cached_data.get("versions", [])
                    # Filter cached versions by minimum
                    filtered = [v for v in cached_versions if v.split('.')[0] + '.' + v.split('.')[1] >= min_version]
                    if filtered:
                        print(f"Using cached versions (cache is {cache_age_hours:.1f} hours old)", file=sys.stderr)
                        return filtered
            except Exception as e:
                print(f"Failed to read cache file: {e}", file=sys.stderr)
                pass

    # Default fallbacks in case API access fails - for Houdini 20.5+
    fallback_versions = [HOUDINI_FALLBACK_VERSION]  # Known production build for 20.5

    # Get credentials from environment
    username = os.environ.get("SIDEFX_USERNAME")
    password = os.environ.get("SIDEFX_PASSWORD")

    # If credentials aren't available, use fallbacks
    if not username or not password:
        print("SideFX credentials not found, using fallback versions", file=sys.stderr)
        return fallback_versions

    try:
        # Common browser-like headers
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Referer": "https://www.sidefx.com/login/",
            "Connection": "keep-alive"
        }

        # Create session and authenticate
        session = requests.Session()
        session.headers.update(headers)

        # First get the login page to obtain any CSRF tokens
        login_page = session.get("https://www.sidefx.com/login/")

        # Add a small delay to mimic human behavior
        time.sleep(1)

        # Prepare login data
        login_data = {
            "username": username,
            "password": password,
            "next": "/download/daily-builds/get/"  # Direct to builds page after login
        }

        # Extract CSRF token if present
        import re
        csrf_match = re.search(r'name="csrfmiddlewaretoken" value="([^"]+)"', login_page.text)
        if csrf_match:
            login_data["csrfmiddlewaretoken"] = csrf_match.group(1)
            session.headers.update({"Referer": "https://www.sidefx.com/login/"})

        # Perform login
        login_resp = session.post(
            "https://www.sidefx.com/login/",
            data=login_data,
            allow_redirects=True
        )
        if login_resp.status_code != 200:
            print(f"Login failed: {login_resp.status_code}", file=sys.stderr)
            return fallback_versions

        # Add another small delay
        time.sleep(1)

        # Get the build list
        build_resp = session.get("https://www.sidefx.com/download/daily-builds/get/")

        if build_resp.status_code != 200:
            print(f"Failed to get build list: {build_resp.status_code}", file=sys.stderr)
            return fallback_versions

        # Try to parse the JSON response
        try:
            build_data = build_resp.json()
        except json.JSONDecodeError as e:
            print(f"Failed to parse JSON response: {e}", file=sys.stderr)
            return fallback_versions

        # Process the daily builds from the JSON structure
        production_builds = []

        # Check in daily_builds_releases
        for build in build_data.get("daily_builds_releases", []):
            # Only consider production builds (we know these are all "devel" for now)
            # Only consider standard Houdini (not Qt6, py310, etc.)
            if (build.get("product") == "houdini" and
                # Include both gold and devel releases
                (build.get("release") in ["gold", "devel"]) and
                # Make sure the package exists
                build.get("package_exists") and
                # Not marked as bad quality
                not build.get("bad_quality")):

                version = build.get("version")
                build_num = build.get("build")

                # Check if version meets minimum requirement
                if version and build_num:
                    full_version = f"{version}.{build_num}"

                    # Only include versions >= min_version
                    if is_version_gte(version, min_version):
                        production_builds.append({
                            "full_version": full_version,
                            "version": version,
                            "build": build_num,
                            "release": build.get("release")
                        })

        # Group by major.minor version
        version_groups = defaultdict(list)
        for build in production_builds:
            version_groups[build["version"]].append(build)

        # For each major.minor, select oldest and newest
        test_versions = []
        for version, builds in version_groups.items():
            # Sort by build number
            sorted_builds = sorted(builds, key=lambda b: int(b["build"]))

            if sorted_builds:
                # Get oldest production build for this version
                oldest = sorted_builds[0]["full_version"]
                test_versions.append(oldest)

                # Get newest production build for this version if different
                if len(sorted_builds) > 1:
                    newest = sorted_builds[-1]["full_version"]
                    if newest != oldest:
                        test_versions.append(newest)

                # If there's a gold release, ensure it's included
                gold_builds = [b["full_version"] for b in sorted_builds if b["release"] == "gold"]
                if gold_builds and gold_builds[0] not in test_versions:
                    test_versions.append(gold_builds[0])

        # Fallback if we couldn't find any versions
        if not test_versions:
            return fallback_versions

        # Cache the results
        if cache_file:
            try:
                with open(cache_file, 'w') as f:
                    # Include metadata about when cache was created
                    cache_data = {
                        "versions": test_versions,
                        "cache_date": datetime.now().isoformat(),
                        "min_version": min_version
                    }
                    json.dump(cache_data, f)
            except Exception as e:
                print(f"Failed to write cache: {e}", file=sys.stderr)

        return test_versions

    except Exception as e:
        print(f"Error fetching versions: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return fallback_versions


def download_houdini_installer(version, platform="linux", arch="arm64", build_type="gcc9.3", session=None):
    """Download a specific Houdini installer."""
    if not session:
        session = requests.Session()
        # Login first using credentials from environment
        login_session(session)

    # Parse version parts
    version_parts = version.split('.')
    main_version = '.'.join(version_parts[:2])  # e.g., "20.5"
    build_num = version_parts[2] if len(version_parts) > 2 else ""

    # Create download URL
    download_url = f"https://www.sidefx.com/download/download-houdini-{main_version}/{platform}/houdini-{main_version}.{build_num}-{platform}_{arch}_{build_type}.tar.gz"

    # Create cache directory
    download_dir = Path(os.getenv("HOUDINI_DOWNLOAD_DIR", HOUDINI_DEFAULT_CACHE_DIR / "installers"))
    download_dir.mkdir(exist_ok=True, parents=True)

    # Output file path
    output_file = download_dir / f"houdini-{main_version}.{build_num}-{platform}_{arch}_{build_type}.tar.gz"

    # Skip if file already exists
    if output_file.exists():
        print(f"Installer already exists: {output_file}", file=sys.stderr)
        return output_file

    print(f"Downloading Houdini {version} for {platform}_{arch}...", file=sys.stderr)

    # Stream download to file with progress indicator
    with session.get(download_url, stream=True) as r:
        r.raise_for_status()
        total_size = int(r.headers.get('content-length', 0))
        downloaded = 0
        with open(output_file, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8192):
                f.write(chunk)
                downloaded += len(chunk)
                # Show progress
                if total_size > 0:
                    done = int(50 * downloaded / total_size)
                    sys.stderr.write(f"\r[{'=' * done}{' ' * (50-done)}] {downloaded/1024/1024:.1f}/{total_size/1024/1024:.1f} MB")
                    sys.stderr.flush()

        if total_size > 0:
            sys.stderr.write("\n")

    print(f"Downloaded to: {output_file}", file=sys.stderr)
    return output_file

def login_session(session):
    """Login to SideFX using environment credentials."""
    # Get credentials from environment
    username = os.environ.get("SIDEFX_USERNAME")
    password = os.environ.get("SIDEFX_PASSWORD")

    if not username or not password:
        raise ValueError("SIDEFX_USERNAME and SIDEFX_PASSWORD must be set (via environment or .env file)")

    # Re-use your existing login code here...
    # (Same code as your function from get_version_range_for_testing)

    # Common browser-like headers
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Referer": "https://www.sidefx.com/login/",
        "Connection": "keep-alive"
    }

    session.headers.update(headers)

    # First get the login page to obtain CSRF token
    login_page = session.get("https://www.sidefx.com/login/")

    # Add a small delay
    time.sleep(1)

    # Prepare login data
    login_data = {
        "username": username,
        "password": password,
        "next": "/download/daily-builds/get/"
    }

    # Extract CSRF token if present
    import re
    csrf_match = re.search(r'name="csrfmiddlewaretoken" value="([^"]+)"', login_page.text)
    if csrf_match:
        login_data["csrfmiddlewaretoken"] = csrf_match.group(1)
        session.headers.update({"Referer": "https://www.sidefx.com/login/"})

    # Perform login
    login_resp = session.post(
        "https://www.sidefx.com/login/",
        data=login_data,
        allow_redirects=True
    )

    if login_resp.status_code != 200:
        raise Exception(f"Login failed: {login_resp.status_code}")

    return session

# Create a click group as the main entry point
@click.group()
def cli():
    """Houdini version management tools."""
    pass

# First subcommand - get versions
@cli.command('versions')
@click.option('--cache-dir',
              default=os.getenv("HOUDINI_VERSIONS_CACHE",
                                HOUDINI_DEFAULT_CACHE_DIR),
              help='Directory to cache Houdini versions.')
@click.option('--min-version',
              default=os.getenv("HOUDINI_MIN_VERSION",
                                HOUDINI_DEFAULT_MIN_VERSION),
              help='Minimum Houdini version to consider.')
def versions_command(cache_dir: Path|str=HOUDINI_VERSIONS_CACHE,
                    min_version: str="20.5"):
    """Get Houdini versions for testing."""
    cache_dir = Path(cache_dir)
    cache_dir.mkdir(exist_ok=True, parents=True)
    cache_file = cache_dir / Path(HOUDINI_VERSIONS_CACHE_NAME).name

    # Get versions
    versions = get_version_range_for_testing(min_version, cache_file)

    # Output as JSON
    print(json.dumps(versions))

# Add this to your imports
# dotenv already imported at the top

@cli.command('download')
@click.option('--version',
              default=os.getenv("HOUDINI_VERSION", HOUDINI_FALLBACK_VERSION),
              help='Specific Houdini version to download.')
@click.option('--arch',
              default=os.getenv("HOUDINI_ARCH", "arm64"),
              help='CPU architecture (arm64 or x86_64).')
@click.option('--build-type',
              default=os.getenv("HOUDINI_BUILD_TYPE", "gcc9.3"),
              help='Build type (gcc9.3, gcc11.2, etc).')
@click.option('--output-path',
              help='Path to save the downloaded file (for Docker integration).')
@click.option('--credentials',
              help='Path to .env file with SIDEFX_USERNAME and SIDEFX_PASSWORD')
def download_command(version: str=HOUDINI_FALLBACK_VERSION,
                   arch: str="arm64",
                   build_type: str="gcc9.3",
                   output_path: str|Path|None=None,
                   credentials: str|Path|None=None,
                ):
    """Download a Houdini installer."""
    try:
        # Load credentials file if provided
        if credentials:
            load_dotenv(dotenv_path=credentials, override=True)

        session = requests.Session()
        login_session(session)
        # Rest of your download code...
        installer_path = download_houdini_installer(
            version=version,
            arch=arch,
            build_type=build_type,
            session=session
        )

        # If output path is specified, copy there (for Docker build)
        if output_path:
            import shutil
            output_path = Path(output_path)
            output_path.parent.mkdir(exist_ok=True, parents=True)
            shutil.copy2(installer_path, output_path)
            print(f"Copied to: {output_path}", file=sys.stderr)

        # Print the path to stdout for capturing in scripts
        print(installer_path)
    except Exception as e:
        print(f"Error downloading Houdini: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    cli()  # Use the cli group instead of main function
