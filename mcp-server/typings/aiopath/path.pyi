"""
This type stub file was generated by pyright.
"""

from os import stat_result
from pathlib import Path, PurePath
from typing import AsyncContextManager, AsyncIterable, Literal, Self, overload

from anyio import AsyncFile
from .handle import Handle
from .metadata import docs_from
from .types import FileMode, Paths

class AsyncPurePath(PurePath):
  """
  An implementation of pathlib.PurePath that returns asynchronous Path objects.

  Instead of returning PurePath objects, AsyncPurePath returns AsyncPath objects.
  """
  __slots__ = ...
  @docs_from(PurePath)
  def __rtruediv__(self, key: Paths) -> Self:
    ...

  @docs_from(PurePath)
  def __truediv__(self, key: Paths) -> Self:
    ...

  @property
  @docs_from(PurePath)
  def parent(self: Self) -> Self:
    ...

  @property
  @docs_from(PurePath)
  def parents(self: Self) -> tuple[Self, ...]:
    ...

  @docs_from(PurePath)
  def joinpath(self: Self, *pathsegments: str) -> Self:
    ...

  @docs_from(PurePath)
  def relative_to(self, other: Paths, /, *_deprecated, walk_up: bool = ...) -> Self:
    ...

  @docs_from(PurePath)
  def with_name(self: Self, name: str) -> Self:
    ...

  @docs_from(PurePath)
  def with_suffix(self: Self, suffix: str) -> Self:
    ...



class AsyncPath(AsyncPurePath, Path):
  """An asynchronous implementation of pathlib.Path."""
  __slots__ = ...
  @classmethod
  @docs_from(Path)
  async def cwd(cls) -> Self:
    ...

  @classmethod
  @docs_from(Path)
  async def home(cls) -> Self:
    ...

  @docs_from(Path)
  async def absolute(self: Self) -> Self:
    ...

  @docs_from(Path)
  async def chmod(self, mode: FileMode, *, follow_symlinks: bool = ...):
    ...

  @docs_from(Path)
  async def exists(self, *, follow_symlinks: bool = ...) -> bool:
    ...

  @docs_from(Path)
  async def expanduser(self: Self) -> Self:
    ...

  @docs_from(Path)
  async def glob(self: Self, pattern: str, *, case_sensitive: bool | None = ...) -> AsyncIterable[Self]:
    ...

  @docs_from(Path)
  async def group(self) -> str:
    ...

  @docs_from(Path)
  async def hardlink_to(self, target: Paths):
    ...

  @docs_from(Path)
  async def is_block_device(self) -> bool:
    ...

  @docs_from(Path)
  async def is_char_device(self) -> bool:
    ...

  @docs_from(Path)
  async def is_dir(self) -> bool:
    ...

  @docs_from(Path)
  async def is_fifo(self) -> bool:
    ...

  @docs_from(Path)
  async def is_file(self) -> bool:
    ...

  @docs_from(Path)
  async def is_mount(self) -> bool:
    ...

  @docs_from(Path)
  async def is_socket(self) -> bool:
    ...

  @docs_from(Path)
  async def is_symlink(self) -> bool:
    ...

  @docs_from(Path)
  async def iterdir(self: Self) -> AsyncIterable[Self]:
    ...

  @docs_from(Path)
  async def lchmod(self, mode: FileMode):
    ...

  @docs_from(Path)
  async def lstat(self) -> stat_result:
    ...

  @docs_from(Path)
  async def match(self, path_pattern: str, *, case_sensitive: bool | None = ...) -> bool:
    ...

  @docs_from(Path)
  async def mkdir(self, mode: int = ..., parents: bool = ..., exist_ok: bool = ...):
    ...

  @docs_from(Path)
  @overload
  def open(self, mode: Literal['rb', 'wb', 'wb+'] = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> AsyncContextManager[AsyncFile[bytes]]:
    ...
  @overload
  def open(self, mode: Literal['r', 'w', 'w+'], buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> AsyncContextManager[AsyncFile[str]]:
    ...
  @overload
  def open(self, mode: str = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> AsyncContextManager[AsyncFile[str]|AsyncFile[bytes]]:
    ...
  def open(self, mode: str = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> AsyncContextManager[AsyncFile[str]|AsyncFile[bytes]]:
    ...

  @docs_from(Path)
  async def owner(self) -> str:
    ...

  @docs_from(Path)
  async def read_bytes(self) -> bytes:
    ...

  @docs_from(Path)
  async def read_text(self, encoding: str | None = ..., errors: str | None = ...) -> str:
    ...

  @docs_from(Path)
  async def readlink(self: Self) -> Self:
    ...

  @docs_from(Path)
  async def rename(self: Self, target: Paths) -> Self:
    ...

  @docs_from(Path)
  async def replace(self: Self, target: Paths) -> Self:
    ...

  @docs_from(Path)
  async def resolve(self: Self, strict: bool = ...) -> Self:
    ...

  @docs_from(Path)
  async def rglob(self: Self, pattern: str, *, case_sensitive: bool | None = ...) -> AsyncIterable[Self]:
    ...

  @docs_from(Path)
  async def rmdir(self):
    ...

  @docs_from(Path)
  async def samefile(self, other_path: Paths) -> bool:
    ...

  @docs_from(Path)
  async def stat(self, *, follow_symlinks: bool = ...) -> stat_result:
    ...

  @docs_from(Path)
  async def symlink_to(self, target: Paths, target_is_directory: bool = ...):
    ...

  @docs_from(Path)
  async def touch(self, mode: int = ..., exist_ok: bool = ...):
    ...

  @docs_from(Path)
  async def unlink(self, missing_ok: bool = ...):
    ...

  @docs_from(Path)
  async def write_bytes(self, data: bytes) -> int:
    ...

  @docs_from(Path)
  async def write_text(self, data: str, encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> int:
    ...



